**Version:** 0.3-dev
**Last Updated:** May 12, 2025

Relevant areas and examples that touch upon similar functionality to what RedEye aims for, categorized for clarity:

**1. macOS Automation & Contextual Tools (Direct Inspirations/Comparisons):**

*   **PopClip (macOS):** (Existing entry - unchanged)
    *   **Relevance:** Initial inspiration for text-selection triggers.
    *   **Learnings:** UI/UX, extensibility model.
*   **Keyboard Maestro (macOS):** (Existing entry - unchanged)
    *   **Relevance:** Powerful macro tool, vast array of triggers.
    *   **Learnings:** Rich System Event catalog, UI for Compound Event rules, scripting extensibility.
*   **Hazel (macOS):** **(Updated Section)**
    *   **Relevance:** Automated file/folder organization based on rules. Primarily driven by FSEvents.
    *   **Learnings (v0.3 Research):**
        *   **Monitoring:** Confirms `FSEvents` framework is the standard for efficient folder monitoring (**System Event**). Monitors specific folders designated by the user.
        *   **Rule Triggers:** Rules are triggered by FSEvents, but conditions involve significant post-processing:
            *   **Attribute Checks:** (Name, date, size, tags, comments, kind, source URL) - Acts like **Synthetic Event** generation based on file metadata.
            *   **Content Matching:** (Keywords, patterns in text/PDF/images/music) - Clear **Synthetic Event** generation requiring deeper inspection (potentially leveraging Spotlight importers).
            *   **Time Conditions:** (e.g., "older than 30 days") - Creates **Compound Events** (FSEvent + Time).
            *   **Rule Logic:** Conditions combined with "all"/"any" represent simple **Compound Events**.
        *   **Actions:** Performs actions internally (Move, Copy, Rename, Tag, Sort, Open, Run Scripts - AppleScript/Shell/JS). These actions align with tasks RedEye would expect an **Agent** to perform based on received events. The need for file attributes to perform actions (like patterned rename) highlights the value of **Synthetic Event** data (attributes) either generated by RedEye or fetched by the Agent.
        *   **Tech Stack (Inferred):** Likely native Objective-C/Swift, using Foundation, AppKit, CoreServices (FSEvents), file APIs (`FileManager`, resource values), possibly Spotlight importers, and scripting runtimes (`NSAppleScript`, `Process`). It contains its own internal rule engine.
        *   **Architecture:** Monolithic application where sensing (FSEvents), synthesis (condition checking), and action execution happen within the same process. Contrasts with RedEye's sensor/agent split.
*   **BetterTouchTool (BTT) (macOS):** (Existing entry - unchanged)
    *   **Relevance:** Advanced input device customization.
    *   **Learnings:** Sophisticated input event capture and mapping.
*   **Alfred / LaunchBar (macOS):** (Existing entry - unchanged)
    *   **Relevance:** Launchers with workflow/extension systems.
    *   **Learnings:** Extensibility models, script-based custom logic.

**2. Developer-Focused Tools & Frameworks for System Interaction:**

*   **Hammerspoon (macOS):** **(Updated Section)**
    *   **Relevance:** Extremely relevant open-source (MIT License) automation tool. Exposes many low-level macOS APIs to a Lua scripting engine. Essentially a "sensorium construction kit".
    *   **Learnings (v0.3 Research):**
        *   **Architecture:** Native Objective-C core embedding a Lua engine. Uses a custom bridge (`LuaSkin`) to expose macOS frameworks and handle callbacks safely (typically executing Lua callbacks on the main thread).
        *   **Event Modules:** Provides dedicated Lua modules for various event sources:
            *   `hs.eventtap`: Wraps `CGEventTap` for keyboard/mouse (**System Events**).
            *   `hs.pathwatcher`: Wraps `FSEvents` for file system (**System Events**).
            *   `hs.application.watcher`: Wraps `NSWorkspace` notifications for app lifecycle (**System Events**).
            *   Others: `hs.wifi`, `hs.audiodevice`, `hs.caffeinate` (power), `hs.usb`, `hs.screen`, `hs.location`, etc. - primarily exposing **System Events**.
        *   **API Design:** Consistent, callback-based API. Users instantiate watcher objects and provide Lua functions to be called when events occur. `hs.eventtap` passes specific `hs.eventtap.event` objects; others pass relevant Lua types (strings, tables). No unified event object hierarchy.
        *   **Event Handling/Dispatch:** No central Lua "Event Bus". Event handling is decentralized per watcher object. `LuaSkin` marshals native callbacks (which may occur on background threads/queues) to execute the user's Lua callback on the main thread, implicitly queueing them if necessary.
        *   **Event Taxonomy:** Primarily focuses on exposing **System Events**. Users are responsible for implementing **Synthetic** and **Compound** event logic within their Lua callbacks (e.g., debouncing input, checking attributes, combining states).
        *   **Performance:** Main thread dispatch simplifies Lua scripting but can be a bottleneck if callbacks are slow or event volume is high. Users must manage throttling/debouncing in Lua.
        *   **Relevance to RedEye:** Validates choices of macOS frameworks. Callback pattern is analogous to delegates/closures. `LuaSkin` highlights the need for careful thread management when bridging native events to consumers. Decentralized module approach is similar to RedEye's Managers. Contrasts with RedEye's goal of a central `EventBus` and potentially sending typed `RedEyeEvent` objects via IPC.
*   **SwiftNIO / EndpointSecurity / FSEvents / CoreWLAN etc.:** (Existing entry - unchanged)
    *   **Relevance:** Underlying macOS frameworks.
    *   **Learnings:** Understanding capabilities/limitations is key.

**3. Cross-Platform & Conceptual Parallels:** (Existing entries - unchanged)
*   **IFTTT / Zapier:** Trigger -> action model, simple Compound Events.
*   **Node-RED:** Flow-based programming, visual event flows.
*   **Home Assistant / openHAB:** Event bus architectures, rule engines, state machines for sensor aggregation.
*   **CEP Engines:** Formal concepts for complex event pattern detection.

**4. Operating System Internals & Event Systems:** (Existing entries - unchanged)
*   **`launchd` / `systemd`:** OS-level event-driven service management.
*   **Windows Event Log / WMI:** Comprehensive OS eventing on another platform.

**What this means for RedEye v0.3 Planning (Updated Summary):**

1.  **Event Infrastructure (EventBus Refactor - Step 5):**
    *   **Hammerspoon's `LuaSkin`:** Emphasizes the need for RedEye's `EventBus` to handle thread safety, likely dispatching events to subscribers (like `WebSocketServerManager`) on the main thread for simplicity and safety, while allowing event capture/processing to happen asynchronously in Managers.
    *   **Hammerspoon vs. RedEye Bus:** Hammerspoon's lack of a central bus contrasts with RedEye's plan. RedEye's explicit `EventBus` and unified `RedEyeEvent` structure seem better suited for the decoupled IPC model where the Agent expects consistent events.
    *   **Home Assistant / Node-RED:** Conceptual models for event flow and potentially more advanced bus features (filtering, routing) in the future.
2.  **Expanding System Events:**
    *   **Hammerspoon:** Provides an excellent catalog (`hs.*` modules) of achievable **System Events** using native macOS APIs, validating RedEye's direction and suggesting future candidates (WiFi, USB, Audio, Power, Screen).
    *   **Hazel:** Masterclass in leveraging **FSEvents** effectively.
3.  **Designing for Synthetic & Compound Events:**
    *   **Hazel & Hammerspoon:** Both delegate significant **Synthetic** event generation (attribute checks, content matching) and **Compound** event logic (rule evaluation, script logic) to components *after* the initial **System Event** is detected (Hazel's internal engine, Hammerspoon's Lua scripts).
    *   **RedEye's Approach:** This supports RedEye's initial focus on capturing **System Events** and sending them via IPC, letting the Agent handle higher-level synthesis and composition.
    *   **Future RedEye Synthesis:** If RedEye were to generate **Synthetic Events**, performance is key. Hazel's approach (leveraging Spotlight importers) and Hammerspoon's performance caveats (Lua on main thread) suggest that expensive synthesis within RedEye needs careful asynchronous design, throttling, or configuration.
4.  **Performance & IPC:**
    *   RedEye's IPC model requires consideration of event volume. Unlike Hazel/Hammerspoon where load is internal, RedEye must consider IPC overhead.
    *   Implementing throttling, debouncing, or filtering (either configurable in Managers or potentially via the EventBus later) will be important for high-frequency events like keyboard/mouse, especially before IPC transmission.
5.  **RedEye's Niche:**
    *   Findings reinforce RedEye's potential niche: A **lightweight, Swift-native, open-source macOS sensor component** focused on providing a stream of primarily **System Events** (and potentially curated **Synthetic Events**) via a clean IPC interface to external agents, differing from monolithic tools (Hazel, KM) or direct scripting environments (Hammerspoon).
